{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NRTMapMatching Documentation","text":"<p>Welcome to the NRTMapMatching documentation. This documentation provides comprehensive information about the Near Real-time Map Matching library.</p>"},{"location":"#quick-navigation","title":"Quick Navigation","text":"<ul> <li>Overview - Introduction and architecture</li> <li>Installation - Setup and dependencies</li> <li>API Reference - Detailed module and function documentation</li> <li>User Guide - Usage examples and workflows</li> <li>Data Formats - Input/output specifications</li> <li>Algorithms - Algorithm explanations and details</li> <li>Configuration - Parameters and settings</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Install the library</li> <li>Read the Overview to understand the system architecture</li> <li>Follow the User Guide for examples</li> <li>Refer to API Reference for detailed function documentation</li> </ol>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>NRTMapMatching/\n\u251c\u2500\u2500 sources/          # Source code modules\n\u251c\u2500\u2500 test/            # Test notebooks\n\u251c\u2500\u2500 data/            # Sample data files\n\u2514\u2500\u2500 docs/            # Documentation (this folder)\n</code></pre>"},{"location":"#support","title":"Support","text":"<p>For issues and questions, please open an issue on the project repository.</p>"},{"location":"GITHUB_PAGES_SETUP/","title":"Quick Setup Guide for GitHub Pages","text":""},{"location":"GITHUB_PAGES_SETUP/#what-is-github-pages","title":"What is GitHub Pages?","text":"<p>GitHub Pages is a free hosting service that turns your GitHub repository into a website. Your documentation will be accessible at: <pre><code>https://YOUR_USERNAME.github.io/NRTMapMatching\n</code></pre></p>"},{"location":"GITHUB_PAGES_SETUP/#quick-setup-5-minutes","title":"Quick Setup (5 minutes)","text":""},{"location":"GITHUB_PAGES_SETUP/#1-update-repository-urls","title":"1. Update Repository URLs","text":"<p>Edit <code>mkdocs.yml</code> and replace <code>YOUR_USERNAME</code> with your GitHub username in two places:</p> <pre><code>repo_url: https://github.com/YOUR_USERNAME/NRTMapMatching\n</code></pre> <p>And:</p> <pre><code>extra:\n  social:\n    - icon: fontawesome/brands/github\n      link: https://github.com/YOUR_USERNAME/NRTMapMatching\n</code></pre>"},{"location":"GITHUB_PAGES_SETUP/#2-commit-and-push","title":"2. Commit and Push","text":"<pre><code>git add .\ngit commit -m \"Add GitHub Pages documentation setup\"\ngit push origin main\n</code></pre>"},{"location":"GITHUB_PAGES_SETUP/#3-enable-github-pages","title":"3. Enable GitHub Pages","text":"<ol> <li>Go to your repository on GitHub</li> <li>Click Settings \u2192 Pages</li> <li>Under Source, select:</li> <li>Branch: <code>gh-pages</code></li> <li>Folder: <code>/ (root)</code></li> <li>Click Save</li> </ol>"},{"location":"GITHUB_PAGES_SETUP/#4-wait-for-deployment","title":"4. Wait for Deployment","text":"<ol> <li>Go to the Actions tab in your repository</li> <li>Wait for the \"Deploy Documentation\" workflow to complete (1-2 minutes)</li> <li>Your documentation will be live at:    <pre><code>https://YOUR_USERNAME.github.io/NRTMapMatching\n</code></pre></li> </ol>"},{"location":"GITHUB_PAGES_SETUP/#thats-it","title":"That's It! \ud83c\udf89","text":"<p>Your documentation is now live on GitHub Pages. Every time you push changes to the <code>docs/</code> folder or <code>mkdocs.yml</code>, the documentation will automatically rebuild and deploy.</p>"},{"location":"GITHUB_PAGES_SETUP/#preview-locally","title":"Preview Locally","text":"<p>To preview changes before pushing:</p> <pre><code>pip install -r requirements-docs.txt\nmkdocs serve\n</code></pre> <p>Then open http://127.0.0.1:8000</p>"},{"location":"GITHUB_PAGES_SETUP/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Can't find Pages settings? Make sure you're the repository owner or have admin access</li> <li>Workflow not running? Check the Actions tab - it should trigger automatically on push</li> <li>Documentation not updating? Wait a few minutes for GitHub Pages to rebuild</li> </ul>"},{"location":"GITHUB_PAGES_SETUP/#need-help","title":"Need Help?","text":"<p>See the full setup guide in SETUP.md for detailed instructions and troubleshooting.</p>"},{"location":"SETUP/","title":"Setting Up GitHub Pages Documentation","text":"<p>This guide will help you set up GitHub Pages for your documentation using MkDocs.</p>"},{"location":"SETUP/#prerequisites","title":"Prerequisites","text":"<ul> <li>A GitHub repository</li> <li>Python 3.7+ installed</li> <li>Git installed</li> </ul>"},{"location":"SETUP/#step-1-update-configuration","title":"Step 1: Update Configuration","text":"<ol> <li>Open <code>mkdocs.yml</code> in the root directory</li> <li>Replace <code>YOUR_USERNAME</code> with your GitHub username:    <pre><code>repo_url: https://github.com/YOUR_USERNAME/NRTMapMatching\n</code></pre>    And in the social links section:    <pre><code>social:\n  - icon: fontawesome/brands/github\n    link: https://github.com/YOUR_USERNAME/NRTMapMatching\n</code></pre></li> </ol>"},{"location":"SETUP/#step-2-install-dependencies-locally-optional","title":"Step 2: Install Dependencies Locally (Optional)","text":"<p>To preview the documentation locally:</p> <pre><code>pip install -r requirements-docs.txt\n</code></pre>"},{"location":"SETUP/#step-3-test-locally","title":"Step 3: Test Locally","text":"<p>Start the development server:</p> <pre><code>mkdocs serve\n</code></pre> <p>Open http://127.0.0.1:8000 in your browser to preview your documentation.</p>"},{"location":"SETUP/#step-4-enable-github-pages","title":"Step 4: Enable GitHub Pages","text":"<ol> <li>Go to your GitHub repository</li> <li>Click on Settings</li> <li>Scroll down to Pages in the left sidebar</li> <li>Under Source, select:</li> <li>Branch: <code>gh-pages</code></li> <li>Folder: <code>/ (root)</code></li> <li>Click Save</li> </ol>"},{"location":"SETUP/#step-5-push-to-github","title":"Step 5: Push to GitHub","text":"<p>The GitHub Actions workflow will automatically build and deploy your documentation when you push to the main branch:</p> <pre><code>git add .\ngit commit -m \"Add MkDocs documentation setup\"\ngit push origin main\n</code></pre>"},{"location":"SETUP/#step-6-verify-deployment","title":"Step 6: Verify Deployment","text":"<ol> <li>Go to the Actions tab in your GitHub repository</li> <li>You should see a workflow running called \"Deploy Documentation\"</li> <li>Wait for it to complete (usually takes 1-2 minutes)</li> <li>Once complete, your documentation will be available at:    <pre><code>https://YOUR_USERNAME.github.io/NRTMapMatching\n</code></pre></li> </ol>"},{"location":"SETUP/#manual-deployment-alternative","title":"Manual Deployment (Alternative)","text":"<p>If you prefer to deploy manually instead of using GitHub Actions:</p> <pre><code>mkdocs gh-deploy\n</code></pre> <p>This will build the documentation and push it to the <code>gh-pages</code> branch.</p>"},{"location":"SETUP/#troubleshooting","title":"Troubleshooting","text":""},{"location":"SETUP/#documentation-not-appearing","title":"Documentation not appearing","text":"<ol> <li>Check that GitHub Pages is enabled in repository settings</li> <li>Verify the workflow completed successfully in the Actions tab</li> <li>Wait a few minutes for GitHub Pages to update</li> <li>Clear your browser cache</li> </ol>"},{"location":"SETUP/#workflow-fails","title":"Workflow fails","text":"<ol> <li>Check the Actions tab for error messages</li> <li>Ensure <code>mkdocs.yml</code> is valid YAML</li> <li>Verify all documentation files are in the <code>docs/</code> folder</li> </ol>"},{"location":"SETUP/#local-preview-not-working","title":"Local preview not working","text":"<ol> <li>Ensure all dependencies are installed: <code>pip install -r requirements-docs.txt</code></li> <li>Check that <code>mkdocs.yml</code> is in the root directory</li> <li>Verify all markdown files exist in the <code>docs/</code> folder</li> </ol>"},{"location":"SETUP/#customization","title":"Customization","text":""},{"location":"SETUP/#change-theme","title":"Change Theme","text":"<p>Edit <code>mkdocs.yml</code> to use a different theme:</p> <pre><code>theme:\n  name: readthedocs  # or other themes\n</code></pre>"},{"location":"SETUP/#add-plugins","title":"Add Plugins","text":"<p>Add plugins in <code>mkdocs.yml</code>:</p> <pre><code>plugins:\n  - search\n  - minify\n</code></pre>"},{"location":"SETUP/#custom-domain","title":"Custom Domain","text":"<p>To use a custom domain:</p> <ol> <li>Create a file named <code>CNAME</code> in the <code>docs/</code> folder with your domain</li> <li>Configure DNS settings for your domain</li> <li>GitHub Pages will automatically detect and use the CNAME file</li> </ol>"},{"location":"SETUP/#updating-documentation","title":"Updating Documentation","text":"<p>Simply edit the markdown files in the <code>docs/</code> folder and push to GitHub. The workflow will automatically rebuild and deploy the documentation.</p>"},{"location":"SETUP/#features","title":"Features","text":"<p>The documentation includes:</p> <ul> <li>Search functionality - Full-text search across all pages</li> <li>Dark mode - Toggle between light and dark themes</li> <li>Responsive design - Works on desktop and mobile</li> <li>Code highlighting - Syntax highlighting for code blocks</li> <li>Navigation - Easy navigation with tabs and sections</li> <li>Mobile-friendly - Optimized for mobile devices</li> </ul>"},{"location":"algorithms/","title":"Algorithms","text":"<p>This document describes the algorithms used in NRTMapMatching.</p>"},{"location":"algorithms/#map-matching-algorithm","title":"Map Matching Algorithm","text":"<p>The map matching algorithm uses a greedy approach with backtracking to match GPS points to road network edges.</p>"},{"location":"algorithms/#overview","title":"Overview","text":"<ol> <li>Initial Matching: Find candidate edges within search radius for the first GPS point</li> <li>Iterative Matching: For each subsequent GPS point, determine the best matching edge</li> <li>Backtracking: If match quality is poor, backtrack to previous decision point</li> <li>Cost Calculation: Multi-factor cost function for edge selection</li> </ol>"},{"location":"algorithms/#step-by-step-process","title":"Step-by-Step Process","text":""},{"location":"algorithms/#1-initial-point-matching","title":"1. Initial Point Matching","text":"<p>For the first GPS point: - Calculate search radius: <code>radius = MAX_GPS_ERROR + MAX_MAP_ERROR</code> - Find all edges within radius using R-tree spatial index - Store candidate edges for initial matching</p>"},{"location":"algorithms/#2-decision-making","title":"2. Decision Making","text":"<p>For each GPS point, the algorithm makes one of three decisions:</p> <ul> <li>STAY: Vehicle remains on current edge</li> <li>Condition: Remaining edge length &gt;= (max_speed \u00d7 time) + GPS error</li> <li> <p>Candidate edges: Only current edge</p> </li> <li> <p>CHANGE: Vehicle transitions to a new edge</p> </li> <li>Condition: Remaining edge length &lt; (speed \u00d7 time) - GPS error</li> <li> <p>Candidate edges: Outgoing edges from current edge</p> </li> <li> <p>NODECISION: Ambiguous case</p> </li> <li>Condition: Between STAY and CHANGE thresholds</li> <li>Candidate edges: Current edge + outgoing edges</li> </ul>"},{"location":"algorithms/#3-cost-calculation","title":"3. Cost Calculation","text":"<p>For each candidate edge, calculate a multi-factor cost:</p> <pre><code>cost = 1 \u00d7 bearing_error + \n       30 \u00d7 match_point_distance + \n       10 \u00d7 air_distance_error + \n       5 \u00d7 road_distance_error\n</code></pre> <p>If edge is traversed in reverse: <pre><code>cost += 100000  # Large penalty for reverse direction\n</code></pre></p> <p>Cost Components:</p> <ul> <li>Bearing Error: Difference between GPS bearing and edge bearing (degrees)</li> <li>Match Point Distance: Distance from GPS point to nearest point on edge (meters)</li> <li>Air Distance Error: Difference between GPS distance and matched distance (meters)</li> <li>Road Distance Error: Difference between predicted distance (speed \u00d7 time) and actual road distance (meters)</li> </ul>"},{"location":"algorithms/#4-edge-selection","title":"4. Edge Selection","text":"<ul> <li>Select candidate edge with minimum cost</li> <li>Verify match quality: distance &lt; search radius</li> <li>If quality is poor, backtrack to previous decision point</li> </ul>"},{"location":"algorithms/#5-backtracking","title":"5. Backtracking","text":"<p>If match quality is poor (distance &gt; radius): 1. Remove current edge from candidate list 2. Pop decision from decision list 3. Remove edge from path 4. Return to previous GPS point 5. Try alternative candidate edges</p>"},{"location":"algorithms/#6-edge-transition-handling","title":"6. Edge Transition Handling","text":"<p>When transitioning between edges: - Combine edge shapes for smooth transitions - Calculate road distance across edges - Track edge direction (forward/reverse)</p>"},{"location":"algorithms/#cost-function-details","title":"Cost Function Details","text":"<p>The cost function balances multiple factors:</p> Factor Weight Description Bearing Error 1 Alignment of GPS and edge direction Match Distance 30 Geometric distance to edge Air Distance Error 10 Consistency of GPS movement Road Distance Error 5 Consistency with speed"},{"location":"algorithms/#search-radius","title":"Search Radius","text":"<p>The search radius determines candidate edges: <pre><code>search_radius = MAX_GPS_ERROR + MAX_MAP_ERROR\n</code></pre></p> <p>Typical values: - High GPS accuracy: 30-50 meters - Medium GPS accuracy: 60-80 meters - Low GPS accuracy: 100+ meters</p>"},{"location":"algorithms/#performance-optimizations","title":"Performance Optimizations","text":"<ol> <li>Spatial Indexing: R-tree for efficient edge queries</li> <li>Early Termination: Maximum running time limit</li> <li>Backtracking Limit: Prevents infinite loops</li> <li>Edge Caching: Reuses edge shape calculations</li> </ol>"},{"location":"algorithms/#bezier-interpolation-algorithm","title":"Bezier Interpolation Algorithm","text":"<p>The interpolation uses cubic Bezier curves to create smooth trajectories between GPS points.</p>"},{"location":"algorithms/#overview_1","title":"Overview","text":"<ul> <li>Uses cubic Bezier curves (4 control points)</li> <li>Control points positioned based on velocity vectors</li> <li>Maintains realistic speeds and bearings</li> <li>Handles stops appropriately</li> </ul>"},{"location":"algorithms/#cubic-bezier-curve","title":"Cubic Bezier Curve","text":"<p>A cubic Bezier curve is defined by four control points P\u2080, P\u2081, P\u2082, P\u2083:</p> <pre><code>B(t) = (1-t)\u00b3P\u2080 + 3(1-t)\u00b2tP\u2081 + 3(1-t)t\u00b2P\u2082 + t\u00b3P\u2083\n</code></pre> <p>Where: - t \u2208 [0, 1] is the parameter - P\u2080 is the start point (point a) - P\u2083 is the end point (point b) - P\u2081 and P\u2082 are control points</p>"},{"location":"algorithms/#control-point-calculation","title":"Control Point Calculation","text":"<p>Control points are calculated based on velocity vectors:</p> <ol> <li> <p>Calculate velocity vectors from speed and bearing:    <pre><code>v_a_x = (speed_a + 1) \u00d7 sin(bearing_a)\nv_a_y = (speed_a + 1) \u00d7 cos(bearing_a)\n</code></pre></p> </li> <li> <p>Calculate control point distances:    <pre><code>control = 10 + max(speed_a, speed_b)^1.2\nalpha = (0.5 \u00d7 \u221a(speed_a+1) / (\u221a(speed_a+1) + control)) \u00d7 distance \u00d7 3\nbeta = (0.5 \u00d7 \u221a(speed_b+1) / (\u221a(speed_b+1) + control)) \u00d7 distance \u00d7 3\n</code></pre></p> </li> <li> <p>Position control points:    <pre><code>P\u2081 = P\u2080 + (alpha \u00d7 v_a) / 3\nP\u2082 = P\u2083 - (beta \u00d7 v_b) / 3\n</code></pre></p> </li> </ol>"},{"location":"algorithms/#interpolation-process","title":"Interpolation Process","text":"<p>For each pair of consecutive points (a, b):</p> <ol> <li>Check if stopped: If both points are stopped, maintain constant position</li> <li>Calculate control points: Based on velocity vectors</li> <li>Sample curve: Evaluate Bezier curve at regular intervals (sample_rate)</li> <li>Calculate interpolated values:</li> <li>Position: B(t) from Bezier curve</li> <li>Speed: Distance between consecutive interpolated points / sample_rate</li> <li>Bearing: Derivative of Bezier curve (tangent direction)</li> </ol>"},{"location":"algorithms/#speed-and-bearing-calculation","title":"Speed and Bearing Calculation","text":"<p>Speed: - Calculated from distance between consecutive interpolated points - <code>speed = distance / sample_rate</code></p> <p>Bearing: - Calculated from derivative of Bezier curve - Derivative gives velocity vector (tangent to curve) - Bearing is angle of velocity vector</p>"},{"location":"algorithms/#stop-handling","title":"Stop Handling","text":"<p>When both points are stopped (<code>stopindex &gt; 0</code>): - Maintain constant position (no interpolation) - Speed = 0 - Bearing = previous bearing - Create points at regular intervals with same position</p>"},{"location":"algorithms/#data-cleaning-algorithm","title":"Data Cleaning Algorithm","text":""},{"location":"algorithms/#outlier-removal","title":"Outlier Removal","text":"<p>Outliers are removed based on speed:</p> <ol> <li> <p>Calculate estimated speed between consecutive points:    <pre><code>speed_estimated = distance / time_delta\n</code></pre></p> </li> <li> <p>Remove point if <code>speed_estimated &gt; MAX_SPEED_FOR_OUTLIER</code></p> </li> </ol>"},{"location":"algorithms/#smoothing","title":"Smoothing","text":"<p>Exponential weighted moving average (EWMA) of velocity:</p> <ol> <li> <p>Calculate velocity components:    <pre><code>vx = (x_next - x) / time_delta\nvy = (y_next - y) / time_delta\n</code></pre></p> </li> <li> <p>Apply EWMA smoothing:    <pre><code>vx_smoothed = EWMA(vx, alpha)\nvy_smoothed = EWMA(vy, alpha)\n</code></pre></p> </li> <li> <p>Update positions:    <pre><code>x_new = x + vx_smoothed \u00d7 time_delta\ny_new = y + vy_smoothed \u00d7 time_delta\n</code></pre></p> </li> </ol>"},{"location":"algorithms/#stop-detection","title":"Stop Detection","text":"<p>Stops are detected and handled:</p> <ol> <li>Identify stops: Points with <code>speed &lt; MIN_SPEED</code></li> <li>Assign stop indices: Consecutive stops share same index</li> <li>Fix stop locations: Set stop location to median of consecutive stop points</li> </ol>"},{"location":"algorithms/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"algorithms/#time-complexity","title":"Time Complexity","text":"<ul> <li>Map Matching: O(n \u00d7 m \u00d7 k) where:</li> <li>n = number of GPS points</li> <li>m = average number of candidate edges per point</li> <li> <p>k = average number of backtracking steps</p> </li> <li> <p>Interpolation: O(n \u00d7 s) where:</p> </li> <li>n = number of GPS points</li> <li> <p>s = average number of samples per segment</p> </li> <li> <p>Network Query: O(log n) using R-tree spatial index</p> </li> </ul>"},{"location":"algorithms/#space-complexity","title":"Space Complexity","text":"<ul> <li>Network Storage: O(e + n) where:</li> <li>e = number of edges</li> <li> <p>n = number of nodes</p> </li> <li> <p>Matching State: O(d) where:</p> </li> <li>d = depth of decision tree</li> </ul>"},{"location":"algorithms/#optimization-strategies","title":"Optimization Strategies","text":"<ol> <li>Spatial Indexing: R-tree for O(log n) edge queries</li> <li>Early Termination: Maximum running time limit</li> <li>Backtracking Limit: Prevents excessive backtracking</li> <li>Edge Caching: Reuses shape calculations</li> </ol>"},{"location":"algorithms/#limitations","title":"Limitations","text":"<ol> <li>GPS Accuracy: Algorithm assumes GPS errors &lt; 100m</li> <li>Network Completeness: Requires complete road network data</li> <li>Complex Intersections: May struggle with complex multi-level intersections</li> <li>GPS Gaps: Large time gaps between points may cause issues</li> <li>One-way Streets: Reverse direction matching may need tuning</li> </ol>"},{"location":"api-reference/","title":"API Reference","text":"<p>Complete API documentation for all modules and functions.</p>"},{"location":"api-reference/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Network Module</li> <li>Data Cleaning Module</li> <li>Interpolation Module</li> <li>Map Matching Module</li> <li>Geographic Tools</li> <li>Utilities</li> </ul>"},{"location":"api-reference/#network-module","title":"Network Module","text":"<p>The network module (<code>network.py</code>) provides classes for managing road networks.</p>"},{"location":"api-reference/#classes","title":"Classes","text":""},{"location":"api-reference/#node","title":"<code>Node</code>","text":"<p>Represents a node (intersection) in the road network.</p> <p>Attributes: - <code>coord</code>: Tuple (x, y) representing node coordinates - <code>id</code>: Unique identifier for the node - <code>outgoing</code>: List of outgoing edges - <code>incoming</code>: List of incoming edges</p> <p>Methods: - <code>addIncoming(e)</code>: Add an incoming edge - <code>addOutgoing(e)</code>: Add an outgoing edge - <code>getID()</code>: Get node ID - <code>getIncoming()</code>: Get list of incoming edges - <code>getOutgoing()</code>: Get list of outgoing edges - <code>getCoord()</code>: Get node coordinates</p>"},{"location":"api-reference/#edge","title":"<code>Edge</code>","text":"<p>Represents a road edge (segment) in the network.</p> <p>Attributes: - <code>id</code>: Unique identifier for the edge - <code>fromnode</code>: Source node - <code>tonode</code>: Target node - <code>speed</code>: Speed limit (m/s) - <code>length</code>: Edge length (meters) - <code>shape</code>: List of points defining the edge geometry - <code>incoming</code>: List of incoming edges - <code>outgoing</code>: List of outgoing edges</p> <p>Methods: - <code>getID()</code>: Get edge ID - <code>getShape()</code>: Get edge geometry - <code>getSpeed()</code>: Get speed limit - <code>getLength()</code>: Get edge length - <code>getToNode()</code>: Get target node - <code>getFromNode()</code>: Get source node - <code>getBoundingBox()</code>: Get bounding box for spatial indexing</p>"},{"location":"api-reference/#net","title":"<code>Net</code>","text":"<p>Main network class that manages the entire road network.</p> <p>Attributes: - <code>edges</code>: Dictionary of all edges - <code>nodes</code>: Dictionary of all nodes - <code>geoproj</code>: PyProj projection object for coordinate conversion - <code>_location</code>: Location metadata including projection parameters - <code>_rtree</code>: R-tree spatial index for efficient edge queries</p> <p>Methods:</p>"},{"location":"api-reference/#importfromsumonetsnet","title":"<code>importFromSumoNet(snet)</code>","text":"<p>Import network from SUMO .net file.</p> <p>Parameters: - <code>snet</code>: SUMO network object from <code>sumolib.net.readNet()</code></p> <p>Example: <pre><code>import sumolib\nnet1 = sumolib.net.readNet(\"network.net\", withInternal=False)\nmynet = network.Net()\nmynet.importFromSumoNet(net1)\n</code></pre></p>"},{"location":"api-reference/#importfromosmosmfile","title":"<code>importFromOSM(osmfile)</code>","text":"<p>Import network from OpenStreetMap file.</p> <p>Parameters: - <code>osmfile</code>: Path to OSM file (.osm or .osm.pbf)</p> <p>Example: <pre><code>mynet = network.Net()\nmynet.importFromOSM(\"network.osm\")\n</code></pre></p>"},{"location":"api-reference/#getneighboringedgesx-y-r","title":"<code>getNeighboringEdges(x, y, r)</code>","text":"<p>Find edges within radius <code>r</code> of point (x, y).</p> <p>Parameters: - <code>x</code>: X coordinate - <code>y</code>: Y coordinate - <code>r</code>: Search radius in meters</p> <p>Returns: - List of tuples <code>(edge, distance)</code> for edges within radius</p>"},{"location":"api-reference/#convertlonlat2xylon-lat-rawutmfalse","title":"<code>convertLonLat2XY(lon, lat, rawUTM=False)</code>","text":"<p>Convert longitude/latitude to local coordinates.</p> <p>Parameters: - <code>lon</code>: Longitude (degrees) - <code>lat</code>: Latitude (degrees) - <code>rawUTM</code>: If True, return raw UTM coordinates without offset</p> <p>Returns: - Tuple (x, y) in local coordinate system</p>"},{"location":"api-reference/#convertxy2lonlatx-y-rawutmfalse","title":"<code>convertXY2LonLat(x, y, rawUTM=False)</code>","text":"<p>Convert local coordinates to longitude/latitude.</p> <p>Parameters: - <code>x</code>: X coordinate - <code>y</code>: Y coordinate - <code>rawUTM</code>: If True, treat input as raw UTM coordinates</p> <p>Returns: - Tuple (lon, lat) in degrees</p>"},{"location":"api-reference/#getnoden","title":"<code>getNode(n)</code>","text":"<p>Get node by ID.</p> <p>Parameters: - <code>n</code>: Node ID</p> <p>Returns: - Node object</p>"},{"location":"api-reference/#getedgen","title":"<code>getEdge(n)</code>","text":"<p>Get edge by ID.</p> <p>Parameters: - <code>n</code>: Edge ID</p> <p>Returns: - Edge object</p>"},{"location":"api-reference/#data-cleaning-module","title":"Data Cleaning Module","text":"<p>The data cleaning module (<code>cleandata.py</code>) provides functions for cleaning and enriching GPS trajectory data.</p>"},{"location":"api-reference/#functions","title":"Functions","text":""},{"location":"api-reference/#cleaningdataobs-net-id0-minspeed_for_bearing1-max_speed_for_outlier100","title":"<code>cleaningData(obs, net, id=0, MINSPEED_FOR_BEARING=1, MAX_SPEED_FOR_OUTLIER=100)</code>","text":"<p>Cleans GPS observation data by validating required columns, converting coordinates, removing outliers, and handling stops.</p> <p>Parameters: - <code>obs</code>: DataFrame with columns: lon, lat, timestamp, speed, bearing - <code>net</code>: Network object for coordinate conversion - <code>id</code>: Trajectory ID (default: 0) - <code>MINSPEED_FOR_BEARING</code>: Minimum speed for bearing calculation (m/s, default: 1) - <code>MAX_SPEED_FOR_OUTLIER</code>: Maximum speed for outlier detection (m/s, default: 100)</p> <p>Returns: - DataFrame with columns: id, x, y, timestamp, speed, bearing, stopindex</p> <p>Raises: - Prints error message and returns 0 if required columns are missing</p>"},{"location":"api-reference/#richdataobs-net-id0-alpha7-typelocal-min_speed1-max_speed_for_outlier50-minspeed_for_bearing2","title":"<code>richdata(obs, net, id=0, alpha=.7, type=\"local\", MIN_SPEED=1, MAX_SPEED_FOR_OUTLIER=50, MINSPEED_FOR_BEARING=2)</code>","text":"<p>Enriches GPS data with additional processing including smoothing and outlier removal.</p> <p>Parameters: - <code>obs</code>: DataFrame with GPS observations - <code>net</code>: Network object - <code>id</code>: Trajectory ID (default: 0) - <code>alpha</code>: Smoothing parameter for exponential moving average, 0-1 (default: 0.7) - <code>type</code>: Smoothing type, \"local\" or \"aggregated\" (default: \"local\") - <code>MIN_SPEED</code>: Minimum speed threshold (m/s, default: 1) - <code>MAX_SPEED_FOR_OUTLIER</code>: Maximum speed for outlier detection (m/s, default: 50) - <code>MINSPEED_FOR_BEARING</code>: Minimum speed for bearing calculation (m/s, default: 2)</p> <p>Returns: - Enriched DataFrame with columns: id, x, y, timestamp, speed, bearing, stopindex</p>"},{"location":"api-reference/#smoothingpointobs-alpha7-typelocal","title":"<code>smoothingPoint(obs, alpha=.7, type=\"local\")</code>","text":"<p>Smooths GPS points using exponential weighted moving average of velocity.</p> <p>Parameters: - <code>obs</code>: DataFrame with x, y, timestamp columns - <code>alpha</code>: Smoothing parameter, 0-1, higher = less smoothing (default: 0.7) - <code>type</code>: Smoothing type, \"local\" or \"aggregated\" (default: \"local\")</p> <p>Returns: - DataFrame with smoothed x, y coordinates</p>"},{"location":"api-reference/#removeoutlierobs-max_speed_for_outlier50","title":"<code>removeOutlier(obs, MAX_SPEED_FOR_OUTLIER=50)</code>","text":"<p>Removes GPS points that would require unrealistic speeds.</p> <p>Parameters: - <code>obs</code>: DataFrame with x, y, timestamp columns - <code>MAX_SPEED_FOR_OUTLIER</code>: Maximum allowed speed (m/s, default: 50)</p> <p>Returns: - Filtered DataFrame</p>"},{"location":"api-reference/#xystop_point_editingdf","title":"<code>xystop_point_editing(df)</code>","text":"<p>Sets stop locations to the median of consecutive stop points.</p> <p>Parameters: - <code>df</code>: DataFrame with stopindex column</p> <p>Returns: - DataFrame with updated x, y coordinates for stops</p>"},{"location":"api-reference/#interpolation-module","title":"Interpolation Module","text":"<p>The interpolation module (<code>interpolation.py</code>) provides trajectory interpolation using Bezier curves.</p>"},{"location":"api-reference/#functions_1","title":"Functions","text":""},{"location":"api-reference/#interpolatetrajectorytraj-sample_rate1","title":"<code>interpolateTrajectory(traj, sample_rate=1)</code>","text":"<p>Interpolates a trajectory to create points at regular time intervals using Bezier curves.</p> <p>Parameters: - <code>traj</code>: DataFrame with columns: x, y, timestamp, speed, bearing, stopindex - <code>sample_rate</code>: Time interval between interpolated points in seconds (default: 1)</p> <p>Returns: - DataFrame with interpolated points including original and extra points</p> <p>Algorithm: - Uses cubic Bezier curves for moving segments - Control points are calculated based on velocity and bearing - Handles stops by maintaining constant position</p>"},{"location":"api-reference/#bezierinterpolationa-b-sample_rate1","title":"<code>bezierInterpolation(a, b, sample_rate=1)</code>","text":"<p>Interpolates between two GPS points using a cubic Bezier curve.</p> <p>Parameters: - <code>a</code>: First point (dict with x, y, timestamp, speed, bearing, stopindex) - <code>b</code>: Second point (dict with x, y, timestamp, speed, bearing, stopindex) - <code>sample_rate</code>: Time interval between points in seconds (default: 1)</p> <p>Returns: - DataFrame with interpolated points</p> <p>Algorithm: - Calculates control points based on velocity vectors - Control point distance depends on speed and distance between points - Uses derivative of Bezier curve to calculate bearing and speed</p>"},{"location":"api-reference/#bezier_3p0-p1-p2-p3-t","title":"<code>Bezier_3(p0, p1, p2, p3, t)</code>","text":"<p>Evaluates a cubic Bezier curve at parameter t.</p> <p>Parameters: - <code>p0, p1, p2, p3</code>: Control points (numpy arrays) - <code>t</code>: Parameter value (0-1)</p> <p>Returns: - Point on the curve (numpy array)</p>"},{"location":"api-reference/#derivative_bezier_3p0-p1-p2-p3-t","title":"<code>derivative_Bezier_3(p0, p1, p2, p3, t)</code>","text":"<p>Calculates the derivative (velocity) of a cubic Bezier curve at parameter t.</p> <p>Parameters: - <code>p0, p1, p2, p3</code>: Control points (numpy arrays) - <code>t</code>: Parameter value (0-1)</p> <p>Returns: - Velocity vector (numpy array)</p>"},{"location":"api-reference/#map-matching-module","title":"Map Matching Module","text":"<p>The map matching module (<code>mapmatching.py</code>) provides the core map matching algorithm.</p>"},{"location":"api-reference/#class-mapmatcher","title":"Class: <code>MapMatcher</code>","text":"<p>Main class for performing map matching.</p>"},{"location":"api-reference/#initialization","title":"Initialization","text":"<pre><code>MapMatcher(net, MAX_GPS_ERROR=60, MAX_MAP_ERROR=40, \n           MAP_ONE_WAY_FIX=True, U_TURN_ON_ONEWAY=False,\n           LOOP=True, MAX_SPEED=100, DIFF_GPS_ERROR=10,\n           MAX_RUNNING_TIME=5)\n</code></pre> <p>Parameters: - <code>net</code>: Network object - <code>MAX_GPS_ERROR</code>: Maximum GPS error in meters (default: 60) - <code>MAX_MAP_ERROR</code>: Maximum map error in meters (default: 40) - <code>MAP_ONE_WAY_FIX</code>: Allow matching to edges in reverse direction (default: True) - <code>U_TURN_ON_ONEWAY</code>: Allow U-turns on one-way streets (default: False) - <code>LOOP</code>: Allow revisiting edges (default: True) - <code>MAX_SPEED</code>: Maximum speed for validation (m/s, default: 100) - <code>DIFF_GPS_ERROR</code>: GPS error difference threshold (meters, default: 10) - <code>MAX_RUNNING_TIME</code>: Maximum running time in seconds (default: 5)</p>"},{"location":"api-reference/#methods","title":"Methods","text":""},{"location":"api-reference/#matchsample_gps","title":"<code>match(sample_gps)</code>","text":"<p>Performs map matching on a GPS trajectory.</p> <p>Parameters: - <code>sample_gps</code>: DataFrame with columns: x, y, timestamp, speed, bearing, stopindex, type</p> <p>Returns: - 1 if successful, 0 if failed</p> <p>Algorithm: 1. Initial point matching: Find candidate edges within search radius 2. For each GPS point:    - Decide whether to stay on current edge or change to new edge    - Calculate cost for each candidate edge    - Select edge with minimum cost    - Handle edge transitions and backtracking if needed</p> <p>Output: - Stores results in <code>self.matchdf</code> DataFrame</p>"},{"location":"api-reference/#save_routematchroutematchfilenone","title":"<code>save_routematch(routematchfile=None)</code>","text":"<p>Saves route matching results (edge sequences).</p> <p>Parameters: - <code>routematchfile</code>: Optional file path to save CSV</p> <p>Returns: - DataFrame with columns: from_edge, edgeid, edge_reverse, from_edge_reverse, departure, arrival, stop_time, travel_time, shape</p>"},{"location":"api-reference/#save_pointmatchpointmatchfilenone","title":"<code>save_pointmatch(pointmatchfile=None)</code>","text":"<p>Saves point matching results (matched GPS points).</p> <p>Parameters: - <code>pointmatchfile</code>: Optional file path to save CSV</p> <p>Returns: - DataFrame with matched points including edge IDs, offsets, and match quality metrics</p>"},{"location":"api-reference/#reset","title":"<code>reset()</code>","text":"<p>Resets the matcher state (clears matchdf and routedf).</p>"},{"location":"api-reference/#show_path","title":"<code>show_path()</code>","text":"<p>Prints the current matched path (edge IDs).</p>"},{"location":"api-reference/#geographic-tools","title":"Geographic Tools","text":"<p>The geographic tools module (<code>geotools.py</code>) provides utility functions for geographic calculations.</p>"},{"location":"api-reference/#functions_2","title":"Functions","text":""},{"location":"api-reference/#distance2dpoint1-point2","title":"<code>distance2d(point1, point2)</code>","text":"<p>Calculates Euclidean distance between two 2D points.</p> <p>Parameters: - <code>point1</code>: Tuple (x, y) of first point - <code>point2</code>: Tuple (x, y) of second point</p> <p>Returns: - Distance in meters</p>"},{"location":"api-reference/#calculate_bearing_anglepoint1-point2","title":"<code>calculate_bearing_angle(point1, point2)</code>","text":"<p>Calculates bearing angle (0-360 degrees) from point1 to point2.</p> <p>Parameters: - <code>point1</code>: Tuple (x, y) of first point - <code>point2</code>: Tuple (x, y) of second point</p> <p>Returns: - Bearing angle in degrees (0-360)</p>"},{"location":"api-reference/#distancepointtolinepoint-line","title":"<code>distancePointToLine(point, line)</code>","text":"<p>Calculates distance from a point to a line segment.</p> <p>Parameters: - <code>point</code>: Tuple (x, y) of point - <code>line</code>: Tuple (line_start, line_end) of line segment</p> <p>Returns: - Distance in meters</p>"},{"location":"api-reference/#polygonoffsetwithminimumdistancetopointpoint-polygon","title":"<code>polygonOffsetWithMinimumDistanceToPoint(point, polygon)</code>","text":"<p>Finds the point on a polygon closest to a given point and returns the offset along the polygon.</p> <p>Parameters: - <code>point</code>: Tuple (x, y) of point - <code>polygon</code>: List of points defining the polygon</p> <p>Returns: - Tuple (offset, closest_point) where offset is distance along polygon</p>"},{"location":"api-reference/#offsetbearingpolygon-offset","title":"<code>offsetBearing(polygon, offset)</code>","text":"<p>Calculates the bearing angle at a specific offset along a polygon.</p> <p>Parameters: - <code>polygon</code>: List of points defining the polygon - <code>offset</code>: Distance along polygon in meters</p> <p>Returns: - Bearing angle in degrees</p> <p>Raises: - <code>ValueError</code>: If offset is greater than polygon length or negative</p>"},{"location":"api-reference/#road_distancecurrentedge-currentoffset-lastedge-lastoffset-lastedgelength","title":"<code>road_distance(currentedge, currentoffset, lastedge, lastoffset, lastedgelength)</code>","text":"<p>Calculates road network distance between two points on edges.</p> <p>Parameters: - <code>currentedge</code>: Current edge ID - <code>currentoffset</code>: Offset along current edge - <code>lastedge</code>: Last edge ID - <code>lastoffset</code>: Offset along last edge - <code>lastedgelength</code>: Length of last edge</p> <p>Returns: - Road distance in meters</p>"},{"location":"api-reference/#calculateutmzonemin_lon-max_lon-min_lat-max_lat","title":"<code>calculateUTMZone(min_lon, max_lon, min_lat, max_lat)</code>","text":"<p>Calculates appropriate UTM zone for a bounding box.</p> <p>Parameters: - <code>min_lon, max_lon</code>: Longitude range (degrees) - <code>min_lat, max_lat</code>: Latitude range (degrees)</p> <p>Returns: - UTM zone number</p>"},{"location":"api-reference/#dflonlat2xydf-net","title":"<code>dfLonLat2XY(df, net)</code>","text":"<p>Converts DataFrame with lon/lat columns to x/y columns.</p> <p>Parameters: - <code>df</code>: DataFrame with lon, lat columns - <code>net</code>: Network object for coordinate conversion</p> <p>Returns: - DataFrame with x, y columns (lon, lat removed)</p>"},{"location":"api-reference/#dfpoint2lonlatdf-net","title":"<code>dfPoint2LonLat(df, net)</code>","text":"<p>Converts DataFrame with x/y columns to lon/lat columns.</p> <p>Parameters: - <code>df</code>: DataFrame with x, y columns - <code>net</code>: Network object for coordinate conversion</p> <p>Returns: - DataFrame with lon, lat columns (x, y removed)</p>"},{"location":"api-reference/#polylengthpolygon","title":"<code>polyLength(polygon)</code>","text":"<p>Calculates total length of a polyline.</p> <p>Parameters: - <code>polygon</code>: List of points defining the polyline</p> <p>Returns: - Total length in meters</p>"},{"location":"api-reference/#utilities","title":"Utilities","text":"<p>The utilities module (<code>util.py</code>) provides logging functions.</p>"},{"location":"api-reference/#functions_3","title":"Functions","text":""},{"location":"api-reference/#get_loggername","title":"<code>get_logger(name)</code>","text":"<p>Creates a logger with file handler.</p> <p>Parameters: - <code>name</code>: Logger name (string)</p> <p>Returns: - Logger object</p> <p>Note: - Creates log directory if it doesn't exist - Logs are saved to <code>../../log/{name}.log</code></p>"},{"location":"configuration/","title":"Configuration","text":"<p>This document describes all configuration parameters available in NRTMapMatching.</p>"},{"location":"configuration/#mapmatcher-parameters","title":"MapMatcher Parameters","text":""},{"location":"configuration/#initialization-parameters","title":"Initialization Parameters","text":"<pre><code>MapMatcher(net, MAX_GPS_ERROR=60, MAX_MAP_ERROR=40, \n           MAP_ONE_WAY_FIX=True, U_TURN_ON_ONEWAY=False,\n           LOOP=True, MAX_SPEED=100, DIFF_GPS_ERROR=10,\n           MAX_RUNNING_TIME=5)\n</code></pre>"},{"location":"configuration/#net-required","title":"<code>net</code> (required)","text":"<ul> <li>Type: Network object</li> <li>Description: Road network object created from <code>network.Net()</code></li> <li>Example: <code>mynet = network.Net(); mynet.importFromSumoNet(sumo_net)</code></li> </ul>"},{"location":"configuration/#max_gps_error-default-60","title":"<code>MAX_GPS_ERROR</code> (default: 60)","text":"<ul> <li>Type: float</li> <li>Units: meters</li> <li>Description: Maximum expected GPS error. Used to calculate search radius.</li> <li>Recommended Values:</li> <li>High accuracy GPS (RTK): 10-30 meters</li> <li>Standard GPS: 30-60 meters</li> <li>Low accuracy GPS: 60-100 meters</li> <li>Urban canyons: 80-120 meters</li> </ul>"},{"location":"configuration/#max_map_error-default-40","title":"<code>MAX_MAP_ERROR</code> (default: 40)","text":"<ul> <li>Type: float</li> <li>Units: meters</li> <li>Description: Maximum expected map/network error. Combined with GPS error for search radius.</li> <li>Recommended Values:</li> <li>High-quality maps: 20-40 meters</li> <li>Standard maps: 40-60 meters</li> <li>Outdated maps: 60-100 meters</li> </ul>"},{"location":"configuration/#map_one_way_fix-default-true","title":"<code>MAP_ONE_WAY_FIX</code> (default: True)","text":"<ul> <li>Type: bool</li> <li>Description: Allow matching to edges in reverse direction (useful for one-way street errors).</li> <li>Use Cases:</li> <li><code>True</code>: When map data may have one-way direction errors</li> <li><code>False</code>: When map data is highly accurate and one-way rules are strict</li> </ul>"},{"location":"configuration/#u_turn_on_oneway-default-false","title":"<code>U_TURN_ON_ONEWAY</code> (default: False)","text":"<ul> <li>Type: bool</li> <li>Description: Allow U-turns on one-way streets.</li> <li>Use Cases:</li> <li><code>True</code>: When vehicles may make U-turns (e.g., delivery vehicles)</li> <li><code>False</code>: Standard road network behavior</li> </ul>"},{"location":"configuration/#loop-default-true","title":"<code>LOOP</code> (default: True)","text":"<ul> <li>Type: bool</li> <li>Description: Allow revisiting edges (useful for loops and roundabouts).</li> <li>Use Cases:</li> <li><code>True</code>: When routes may revisit edges (default)</li> <li><code>False</code>: In dense networks to prevent unrealistic paths</li> </ul>"},{"location":"configuration/#max_speed-default-100","title":"<code>MAX_SPEED</code> (default: 100)","text":"<ul> <li>Type: float</li> <li>Units: meters per second (m/s)</li> <li>Description: Maximum speed for validation (\u2248 360 km/h).</li> <li>Note: Used for edge validation, not for speed limit enforcement</li> </ul>"},{"location":"configuration/#diff_gps_error-default-10","title":"<code>DIFF_GPS_ERROR</code> (default: 10)","text":"<ul> <li>Type: float</li> <li>Units: meters</li> <li>Description: GPS error difference threshold for decision making.</li> <li>Effect: Larger values make decisions more conservative</li> </ul>"},{"location":"configuration/#max_running_time-default-5","title":"<code>MAX_RUNNING_TIME</code> (default: 5)","text":"<ul> <li>Type: float</li> <li>Units: seconds</li> <li>Description: Maximum running time for map matching algorithm.</li> <li>Note: Algorithm will terminate if exceeded (returns 0)</li> </ul>"},{"location":"configuration/#data-cleaning-parameters","title":"Data Cleaning Parameters","text":""},{"location":"configuration/#cleaningdata-parameters","title":"<code>cleaningData()</code> Parameters","text":"<pre><code>cleaningData(obs, net, id=0, MINSPEED_FOR_BEARING=1, MAX_SPEED_FOR_OUTLIER=100)\n</code></pre>"},{"location":"configuration/#obs-required","title":"<code>obs</code> (required)","text":"<ul> <li>Type: pandas.DataFrame</li> <li>Description: GPS observations with required columns</li> </ul>"},{"location":"configuration/#net-required_1","title":"<code>net</code> (required)","text":"<ul> <li>Type: Network object</li> <li>Description: Network for coordinate conversion</li> </ul>"},{"location":"configuration/#id-default-0","title":"<code>id</code> (default: 0)","text":"<ul> <li>Type: int</li> <li>Description: Trajectory ID</li> </ul>"},{"location":"configuration/#minspeed_for_bearing-default-1","title":"<code>MINSPEED_FOR_BEARING</code> (default: 1)","text":"<ul> <li>Type: float</li> <li>Units: m/s</li> <li>Description: Minimum speed for calculating new bearing. Below this, previous bearing is used.</li> <li>Recommended: 0.5-2.0 m/s</li> </ul>"},{"location":"configuration/#max_speed_for_outlier-default-100","title":"<code>MAX_SPEED_FOR_OUTLIER</code> (default: 100)","text":"<ul> <li>Type: float</li> <li>Units: m/s (\u2248 360 km/h)</li> <li>Description: Maximum speed for outlier detection. Points requiring higher speeds are removed.</li> <li>Recommended: 50-150 m/s depending on vehicle type</li> </ul>"},{"location":"configuration/#richdata-parameters","title":"<code>richdata()</code> Parameters","text":"<pre><code>richdata(obs, net, id=0, alpha=.7, type=\"local\", \n         MIN_SPEED=1, MAX_SPEED_FOR_OUTLIER=50, MINSPEED_FOR_BEARING=2)\n</code></pre>"},{"location":"configuration/#alpha-default-07","title":"<code>alpha</code> (default: 0.7)","text":"<ul> <li>Type: float</li> <li>Range: 0.0 - 1.0</li> <li>Description: Smoothing parameter for exponential moving average. Higher = less smoothing.</li> <li>Recommended Values:</li> <li>High GPS noise: 0.5-0.7 (more smoothing)</li> <li>Low GPS noise: 0.7-0.9 (less smoothing)</li> <li>Raw data: 0.9-1.0 (minimal smoothing)</li> </ul>"},{"location":"configuration/#type-default-local","title":"<code>type</code> (default: \"local\")","text":"<ul> <li>Type: str</li> <li>Options: \"local\", \"aggregated\"</li> <li>Description: Smoothing type. Currently only \"local\" is fully implemented.</li> </ul>"},{"location":"configuration/#min_speed-default-1","title":"<code>MIN_SPEED</code> (default: 1)","text":"<ul> <li>Type: float</li> <li>Units: m/s</li> <li>Description: Minimum speed threshold. Speeds below this are set to 0.</li> <li>Recommended: 0.5-2.0 m/s</li> </ul>"},{"location":"configuration/#max_speed_for_outlier-default-50","title":"<code>MAX_SPEED_FOR_OUTLIER</code> (default: 50)","text":"<ul> <li>Type: float</li> <li>Units: m/s (\u2248 180 km/h)</li> <li>Description: Maximum speed for outlier detection.</li> <li>Recommended by Vehicle Type:</li> <li>Bicycles: 15-20 m/s</li> <li>Cars: 40-50 m/s</li> <li>Trucks: 30-40 m/s</li> <li>Highways: 50-60 m/s</li> </ul>"},{"location":"configuration/#minspeed_for_bearing-default-2","title":"<code>MINSPEED_FOR_BEARING</code> (default: 2)","text":"<ul> <li>Type: float</li> <li>Units: m/s</li> <li>Description: Minimum speed for bearing calculation.</li> <li>Recommended: 1-3 m/s</li> </ul>"},{"location":"configuration/#interpolation-parameters","title":"Interpolation Parameters","text":""},{"location":"configuration/#interpolatetrajectory-parameters","title":"<code>interpolateTrajectory()</code> Parameters","text":"<pre><code>interpolateTrajectory(traj, sample_rate=1)\n</code></pre>"},{"location":"configuration/#traj-required","title":"<code>traj</code> (required)","text":"<ul> <li>Type: pandas.DataFrame</li> <li>Description: Cleaned trajectory data</li> </ul>"},{"location":"configuration/#sample_rate-default-1","title":"<code>sample_rate</code> (default: 1)","text":"<ul> <li>Type: float</li> <li>Units: seconds</li> <li>Description: Time interval between interpolated points.</li> <li>Recommended Values:</li> <li>High-frequency analysis: 0.5-1 second</li> <li>Standard analysis: 1-2 seconds</li> <li>Low-frequency analysis: 2-5 seconds</li> </ul>"},{"location":"configuration/#parameter-tuning-guide","title":"Parameter Tuning Guide","text":""},{"location":"configuration/#for-high-gps-accuracy","title":"For High GPS Accuracy","text":"<pre><code>matcher = MapMatcher(\n    mynet,\n    MAX_GPS_ERROR=30,\n    MAX_MAP_ERROR=20,\n    DIFF_GPS_ERROR=5\n)\n\ncleaned = richdata(\n    gps, mynet,\n    alpha=0.8,  # Less smoothing needed\n    MAX_SPEED_FOR_OUTLIER=40\n)\n</code></pre>"},{"location":"configuration/#for-low-gps-accuracy","title":"For Low GPS Accuracy","text":"<pre><code>matcher = MapMatcher(\n    mynet,\n    MAX_GPS_ERROR=100,\n    MAX_MAP_ERROR=60,\n    DIFF_GPS_ERROR=20\n)\n\ncleaned = richdata(\n    gps, mynet,\n    alpha=0.5,  # More smoothing\n    MAX_SPEED_FOR_OUTLIER=60\n)\n</code></pre>"},{"location":"configuration/#for-dense-urban-areas","title":"For Dense Urban Areas","text":"<pre><code>matcher = MapMatcher(\n    mynet,\n    MAX_GPS_ERROR=80,\n    MAX_MAP_ERROR=40,\n    MAP_ONE_WAY_FIX=True,\n    U_TURN_ON_ONEWAY=False,\n    LOOP=False  # Disallow loops\n)\n</code></pre>"},{"location":"configuration/#for-highway-networks","title":"For Highway Networks","text":"<pre><code>matcher = MapMatcher(\n    mynet,\n    MAX_GPS_ERROR=50,\n    MAX_MAP_ERROR=30,\n    MAX_SPEED=150,  # Higher max speed\n    LOOP=True\n)\n\ncleaned = richdata(\n    gps, mynet,\n    MAX_SPEED_FOR_OUTLIER=60  # Higher outlier threshold\n)\n</code></pre>"},{"location":"configuration/#for-real-time-processing","title":"For Real-time Processing","text":"<pre><code>matcher = MapMatcher(\n    mynet,\n    MAX_RUNNING_TIME=2  # Faster timeout\n)\n\n# Use larger sample_rate for faster processing\ninterpolated = interpolateTrajectory(cleaned, sample_rate=2)\n</code></pre>"},{"location":"configuration/#default-configuration-summary","title":"Default Configuration Summary","text":"Parameter Default Typical Range <code>MAX_GPS_ERROR</code> 60 m 30-100 m <code>MAX_MAP_ERROR</code> 40 m 20-60 m <code>alpha</code> 0.7 0.5-0.9 <code>sample_rate</code> 1 s 0.5-5 s <code>MAX_SPEED_FOR_OUTLIER</code> 50 m/s 20-60 m/s <code>MIN_SPEED</code> 1 m/s 0.5-2 m/s"},{"location":"configuration/#best-practices","title":"Best Practices","text":"<ol> <li>Start with defaults: Default values work well for most cases</li> <li>Tune based on GPS quality: Adjust error parameters based on your GPS device</li> <li>Match vehicle type: Adjust speed thresholds for bicycles, cars, trucks</li> <li>Monitor match quality: Use distance metrics in results to tune parameters</li> <li>Test incrementally: Change one parameter at a time to understand effects</li> </ol>"},{"location":"data-formats/","title":"Data Formats","text":"<p>This document describes the data formats used throughout the NRTMapMatching system.</p>"},{"location":"data-formats/#input-gps-data-format","title":"Input GPS Data Format","text":""},{"location":"data-formats/#required-columns","title":"Required Columns","text":"<p>GPS observation data must be a pandas DataFrame with the following columns:</p> Column Type Description <code>lon</code> float Longitude in degrees <code>lat</code> float Latitude in degrees <code>timestamp</code> int Unix timestamp in seconds <code>speed</code> float Speed in meters per second (m/s) <code>bearing</code> int Bearing angle in degrees (0-360)"},{"location":"data-formats/#example","title":"Example","text":"<pre><code>import pandas as pd\n\ngps_data = pd.DataFrame({\n    'lon': [24.7536, 24.7537, 24.7538],\n    'lat': [59.4370, 59.4371, 59.4372],\n    'timestamp': [1609459200, 1609459201, 1609459202],\n    'speed': [10.5, 11.2, 10.8],\n    'bearing': [90, 92, 91]\n})\n</code></pre>"},{"location":"data-formats/#notes","title":"Notes","text":"<ul> <li>Data must be sorted by timestamp</li> <li>Duplicate timestamps are handled (last value kept)</li> <li>Minimum 2 observations required</li> </ul>"},{"location":"data-formats/#cleanedenriched-data-format","title":"Cleaned/Enriched Data Format","text":""},{"location":"data-formats/#columns","title":"Columns","text":"<p>After cleaning or enriching, the DataFrame contains:</p> Column Type Description <code>id</code> int Trajectory ID <code>x</code> float X coordinate in meters (local projection) <code>y</code> float Y coordinate in meters (local projection) <code>timestamp</code> int Unix timestamp in seconds <code>speed</code> float Speed in meters per second (m/s) <code>bearing</code> float Bearing angle in degrees (0-360) <code>stopindex</code> int Stop index (0 = moving, &gt;0 = stopped)"},{"location":"data-formats/#notes_1","title":"Notes","text":"<ul> <li>Coordinates are in local UTM projection (not lon/lat)</li> <li><code>stopindex</code> = 0 indicates vehicle is moving</li> <li><code>stopindex</code> &gt; 0 indicates vehicle is stopped (consecutive stops share same index)</li> <li>Stop locations are set to median of consecutive stop points</li> </ul>"},{"location":"data-formats/#interpolated-data-format","title":"Interpolated Data Format","text":""},{"location":"data-formats/#columns_1","title":"Columns","text":"<p>Interpolated trajectory data includes all cleaned data columns plus:</p> Column Type Description <code>type</code> str Point type: \"origin\" (original) or \"extra\" (interpolated)"},{"location":"data-formats/#notes_2","title":"Notes","text":"<ul> <li>Original GPS points are marked as \"origin\"</li> <li>Interpolated points are marked as \"extra\"</li> <li>Interpolation creates points at regular time intervals (sample_rate)</li> </ul>"},{"location":"data-formats/#map-matching-output-format","title":"Map Matching Output Format","text":""},{"location":"data-formats/#point-matching-results-matchdf","title":"Point Matching Results (<code>matchdf</code>)","text":"<p>Contains matched GPS points with the following columns:</p> Column Type Description <code>index</code> int Original GPS point index <code>timestamp</code> int Unix timestamp in seconds <code>x</code> float Matched X coordinate on road network <code>y</code> float Matched Y coordinate on road network <code>x_sample</code> float Original GPS X coordinate <code>y_sample</code> float Original GPS Y coordinate <code>edgeid</code> str Matched edge ID <code>offset</code> float Offset along edge in meters <code>dist</code> float Distance from GPS to matched point (meters) <code>distbearing</code> float Bearing error in degrees <code>rd</code> float Road distance error (meters) <code>cost_air</code> float Air distance error (meters) <code>matchbearing</code> float Bearing of matched edge segment (degrees) <code>speed</code> float Speed at matched point (m/s) <code>predict_distance</code> float Predicted distance based on speed (meters) <code>matched_road_distance</code> float Actual road distance traveled (meters) <code>edge_reverse</code> bool Whether edge is traversed in reverse <code>from_edge</code> str Previous edge ID (None for first point) <code>from_edge_reverse</code> bool Whether previous edge was reversed <code>edge_length</code> float Length of matched edge (meters) <code>type</code> str Point type from interpolated data <code>decitsion</code> str Decision type (STAY/CHANGE/NODECISION)"},{"location":"data-formats/#route-matching-results-routedf","title":"Route Matching Results (<code>routedf</code>)","text":"<p>Contains edge sequences with the following columns:</p> Column Type Description <code>from_edge</code> str Source edge ID (None for first edge) <code>edgeid</code> str Current edge ID <code>edge_reverse</code> bool Whether edge is traversed in reverse <code>from_edge_reverse</code> bool Whether source edge was reversed <code>departure</code> int Timestamp when entering edge <code>arrival</code> int Timestamp when leaving edge <code>stop_time</code> int Number of stopped points on edge <code>travel_time</code> int Total travel time on edge (seconds) <code>shape</code> LineString Shapely LineString geometry of the edge"},{"location":"data-formats/#notes_3","title":"Notes","text":"<ul> <li>Route matching results are unique edge sequences</li> <li>Each row represents one edge segment in the route</li> <li><code>shape</code> column contains Shapely geometry objects (can be converted to GeoJSON)</li> </ul>"},{"location":"data-formats/#coordinate-systems","title":"Coordinate Systems","text":""},{"location":"data-formats/#geographic-coordinates-lonlat","title":"Geographic Coordinates (lon/lat)","text":"<ul> <li>Standard WGS84 geographic coordinates</li> <li>Longitude: -180 to 180 degrees</li> <li>Latitude: -90 to 90 degrees</li> <li>Used for: Input GPS data, final output</li> </ul>"},{"location":"data-formats/#local-projected-coordinates-xy","title":"Local Projected Coordinates (x/y)","text":"<ul> <li>UTM (Universal Transverse Mercator) projection</li> <li>Automatically determined based on bounding box</li> <li>Units: meters</li> <li>Used for: Internal calculations, network edges</li> </ul>"},{"location":"data-formats/#conversion","title":"Conversion","text":"<p>Use network methods for coordinate conversion:</p> <pre><code># Convert lon/lat to x/y\nx, y = net.convertLonLat2XY(lon, lat)\n\n# Convert x/y to lon/lat\nlon, lat = net.convertXY2LonLat(x, y)\n</code></pre>"},{"location":"data-formats/#data-validation","title":"Data Validation","text":""},{"location":"data-formats/#input-validation","title":"Input Validation","text":"<p>The system validates: - Required columns are present - Minimum number of observations (&gt;= 2) - Timestamp ordering (data is sorted automatically)</p>"},{"location":"data-formats/#error-handling","title":"Error Handling","text":"<ul> <li>Missing columns: Prints error message, returns 0 or empty DataFrame</li> <li>Invalid timestamps: Data is sorted by timestamp</li> <li>Duplicate timestamps: Last value is kept</li> <li>Outliers: Removed based on speed thresholds</li> </ul>"},{"location":"data-formats/#example-workflow","title":"Example Workflow","text":"<pre><code># 1. Load GPS data (lon/lat)\ngps = pd.read_csv(\"gps_data.csv\")\n\n# 2. Clean/enrich (converts to x/y)\ncleaned = richdata(gps, mynet)\n\n# 3. Interpolate (still x/y)\ninterpolated = interpolateTrajectory(cleaned)\n\n# 4. Map match (still x/y)\nmatcher = MapMatcher(mynet)\nmatcher.match(interpolated)\n\n# 5. Convert back to lon/lat if needed\nfrom geotools import dfPoint2LonLat\nmatched_lonlat = dfPoint2LonLat(matcher.matchdf, mynet)\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.7 or higher</li> <li>pip (Python package installer)</li> </ul>"},{"location":"installation/#install-dependencies","title":"Install Dependencies","text":""},{"location":"installation/#basic-installation","title":"Basic Installation","text":"<pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"installation/#required-packages","title":"Required Packages","text":"<p>The project requires the following Python packages:</p> <ul> <li><code>pandas</code> - Data manipulation and analysis</li> <li><code>numpy</code> - Numerical computations</li> <li><code>sumolib</code> - SUMO network file reading</li> <li><code>shapely</code> - Geometric operations</li> <li><code>rtree</code> - Spatial indexing</li> <li><code>pyproj</code> - Coordinate system transformations</li> <li><code>osmnx</code> - OpenStreetMap network processing (for OSM import)</li> <li><code>pyrosm</code> - OSM file reading (for OSM import)</li> </ul> <p>Note: The <code>requirements.txt</code> includes <code>zipfile</code>, which is a built-in Python module and doesn't need to be installed separately.</p>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>For development and testing: - <code>jupyter</code> - For running test notebooks - <code>matplotlib</code> - For visualization (if needed)</p>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, you can verify the installation by importing the modules:</p> <pre><code>import network\nfrom cleandata import richdata\nfrom interpolation import interpolateTrajectory\nfrom mapmatching import MapMatcher\n</code></pre> <p>If no errors occur, the installation was successful.</p>"},{"location":"installation/#network-data","title":"Network Data","text":"<p>You'll also need road network data:</p> <ul> <li>SUMO Networks: <code>.net</code> files created with SUMO's netconvert tool</li> <li>OSM Files: OpenStreetMap <code>.osm</code> or <code>.osm.pbf</code> files</li> </ul> <p>See the User Guide for examples of loading network data.</p>"},{"location":"overview/","title":"Overview","text":""},{"location":"overview/#introduction","title":"Introduction","text":"<p>NRTMapMatching is a Python library for matching GPS trajectory data to road network edges in near real-time. The system processes GPS observations, cleans and enriches the data, interpolates trajectories, and matches them to a road network using an advanced map matching algorithm.</p>"},{"location":"overview/#architecture","title":"Architecture","text":"<p>The system consists of several key components:</p> <ol> <li>Network Module (<code>network.py</code>): Handles road network loading and management</li> <li>Supports SUMO .net files and OpenStreetMap (OSM) files</li> <li>Provides spatial indexing for efficient edge queries</li> <li> <p>Manages coordinate system conversions</p> </li> <li> <p>Data Cleaning Module (<code>cleandata.py</code>): Cleans and enriches GPS observations</p> </li> <li>Removes outliers based on speed thresholds</li> <li>Smooths trajectories using exponential moving averages</li> <li>Detects and handles vehicle stops</li> <li> <p>Calculates derived metrics (speed, bearing)</p> </li> <li> <p>Interpolation Module (<code>interpolation.py</code>): Interpolates trajectories using Bezier curves</p> </li> <li>Uses cubic Bezier curves for smooth path interpolation</li> <li>Maintains realistic speeds and bearings</li> <li> <p>Handles stops appropriately</p> </li> <li> <p>Map Matching Module (<code>mapmatching.py</code>): Core map matching algorithm</p> </li> <li>Multi-factor cost function for edge selection</li> <li>Greedy algorithm with backtracking</li> <li> <p>Handles edge transitions and one-way streets</p> </li> <li> <p>Geographic Tools (<code>geotools.py</code>): Utility functions for geographic calculations</p> </li> <li>Distance calculations</li> <li>Bearing calculations</li> <li>Point-to-line distance</li> <li> <p>Coordinate transformations</p> </li> <li> <p>Utilities (<code>util.py</code>): Logging and utility functions</p> </li> </ol>"},{"location":"overview/#key-features","title":"Key Features","text":"<ul> <li>Road Network Support: Import networks from SUMO .net files or OpenStreetMap files</li> <li>GPS Data Cleaning: Remove outliers and smooth trajectories</li> <li>Data Enrichment: Enhance GPS data with speed and bearing calculations</li> <li>Trajectory Interpolation: Interpolate trajectories using cubic Bezier curves</li> <li>Map Matching: Match GPS points to road network edges using advanced algorithms</li> <li>Spatial Indexing: Efficient edge queries using R-tree spatial indexing</li> <li>Stop Detection: Automatic detection and handling of vehicle stops</li> </ul>"},{"location":"overview/#workflow","title":"Workflow","text":"<p>The typical workflow consists of:</p> <ol> <li>Load Network: Import road network from SUMO or OSM file</li> <li>Load GPS Data: Load GPS observations with required fields</li> <li>Clean/Enrich Data: Remove outliers and enrich with calculated metrics</li> <li>Interpolate Trajectory: Create interpolated points at regular intervals</li> <li>Map Matching: Match GPS points to road network edges</li> <li>Save Results: Export matched points and routes</li> </ol> <p>For detailed examples, see the User Guide.</p>"},{"location":"user-guide/","title":"User Guide","text":"<p>This guide provides step-by-step examples for using NRTMapMatching.</p>"},{"location":"user-guide/#complete-workflow-example","title":"Complete Workflow Example","text":""},{"location":"user-guide/#1-load-a-road-network","title":"1. Load a Road Network","text":"<pre><code>import sumolib\nimport network\n\n# Option A: Load SUMO network\nnet1 = sumolib.net.readNet(\"data/iland.net\", withInternal=False)\nmynet = network.Net()\nmynet.importFromSumoNet(net1)\n\n# Option B: Load OSM network\n# mynet.importFromOSM(\"data/network.osm\")\n</code></pre>"},{"location":"user-guide/#2-load-gps-data","title":"2. Load GPS Data","text":"<pre><code>import pandas as pd\n\n# Load from CSV\ngps = pd.read_csv(\"gps_data.csv\")\n\n# Or from ZIP file\nimport zipfile\nzf = zipfile.ZipFile('data/gps_inside_island.zip')\ngps = pd.read_csv(zf.open(\"gps_inside_island.csv\"))\n\n# Required columns: lon, lat, timestamp, speed, bearing\nprint(gps.columns)\n</code></pre>"},{"location":"user-guide/#3-prepare-gps-data","title":"3. Prepare GPS Data","text":"<pre><code># Select a specific trip\nunique_trip = list(gps[\"trip_id_extended\"].unique())\nsample_gps = gps[gps[\"trip_id_extended\"] == unique_trip[0]]\nsample_gps = sample_gps.sort_values(\"timestamp\").drop_duplicates()\n\n# Ensure required columns exist\nrequired_cols = [\"lon\", \"lat\", \"timestamp\", \"speed\", \"bearing\"]\nassert all(col in sample_gps.columns for col in required_cols)\n</code></pre>"},{"location":"user-guide/#4-clean-and-enrich-data","title":"4. Clean and Enrich Data","text":"<pre><code>from cleandata import richdata\n\n# Enrich data with smoothing and outlier removal\ncleaned = richdata(\n    sample_gps, \n    mynet, \n    id=0, \n    alpha=0.7,  # Smoothing parameter\n    MIN_SPEED=1,\n    MAX_SPEED_FOR_OUTLIER=50,\n    MINSPEED_FOR_BEARING=2\n)\n\n# Or use basic cleaning\n# from cleandata import cleaningData\n# cleaned = cleaningData(sample_gps, mynet, id=0)\n</code></pre>"},{"location":"user-guide/#5-interpolate-trajectory","title":"5. Interpolate Trajectory","text":"<pre><code>from interpolation import interpolateTrajectory\n\n# Interpolate to create points at 1-second intervals\ninterpolated = interpolateTrajectory(cleaned, sample_rate=1)\n\nprint(f\"Original points: {len(cleaned)}\")\nprint(f\"Interpolated points: {len(interpolated)}\")\n</code></pre>"},{"location":"user-guide/#6-perform-map-matching","title":"6. Perform Map Matching","text":"<pre><code>from mapmatching import MapMatcher\n\n# Create matcher with default parameters\nmatcher = MapMatcher(\n    mynet,\n    MAX_GPS_ERROR=60,      # Maximum GPS error in meters\n    MAX_MAP_ERROR=40,      # Maximum map error in meters\n    MAP_ONE_WAY_FIX=True,  # Allow reverse direction matching\n    LOOP=True              # Allow revisiting edges\n)\n\n# Perform matching\nresult = matcher.match(interpolated)\n\nif result == 1:\n    print(\"Map matching successful!\")\nelse:\n    print(\"Map matching failed\")\n</code></pre>"},{"location":"user-guide/#7-save-results","title":"7. Save Results","text":"<pre><code># Save point matching results\npoint_match = matcher.save_pointmatch(\"point_match.csv\")\nprint(f\"Matched {len(point_match)} points\")\n\n# Save route matching results\nroute_match = matcher.save_routematch(\"route_match.csv\")\nprint(f\"Matched {len(route_match)} route segments\")\n\n# Access matched data directly\nprint(matcher.matchdf.head())\nprint(matcher.routedf.head())\n</code></pre>"},{"location":"user-guide/#working-with-results","title":"Working with Results","text":""},{"location":"user-guide/#analyze-point-matches","title":"Analyze Point Matches","text":"<pre><code>import pandas as pd\n\n# Load point matches\npoint_match = pd.read_csv(\"point_match.csv\")\n\n# Calculate match quality metrics\nprint(f\"Average distance error: {point_match['dist'].mean():.2f} meters\")\nprint(f\"Average bearing error: {point_match['distbearing'].mean():.2f} degrees\")\nprint(f\"Max distance error: {point_match['dist'].max():.2f} meters\")\n\n# Filter by quality\ngood_matches = point_match[point_match['dist'] &lt; 20]\nprint(f\"Good matches (&lt; 20m): {len(good_matches)}/{len(point_match)}\")\n</code></pre>"},{"location":"user-guide/#analyze-route-matches","title":"Analyze Route Matches","text":"<pre><code># Load route matches\nroute_match = pd.read_csv(\"route_match.csv\")\n\n# Calculate route statistics\nprint(f\"Total route segments: {len(route_match)}\")\nprint(f\"Total travel time: {route_match['travel_time'].sum()} seconds\")\nprint(f\"Total stop time: {route_match['stop_time'].sum()} seconds\")\n\n# Get edge sequence\nedge_sequence = route_match['edgeid'].tolist()\nprint(f\"Route: {' -&gt; '.join(edge_sequence[:5])}...\")\n</code></pre>"},{"location":"user-guide/#common-use-cases","title":"Common Use Cases","text":""},{"location":"user-guide/#processing-multiple-trajectories","title":"Processing Multiple Trajectories","text":"<pre><code>unique_trips = list(gps[\"trip_id_extended\"].unique())\n\nfor i, trip_id in enumerate(unique_trips[:10]):  # Process first 10 trips\n    print(f\"Processing trip {i+1}/{min(10, len(unique_trips))}: {trip_id}\")\n\n    # Get trip data\n    trip_data = gps[gps[\"trip_id_extended\"] == trip_id]\n    trip_data = trip_data.sort_values(\"timestamp\").drop_duplicates()\n\n    # Process\n    cleaned = richdata(trip_data, mynet, id=i)\n    interpolated = interpolateTrajectory(cleaned, sample_rate=1)\n\n    # Match\n    matcher = MapMatcher(mynet)\n    result = matcher.match(interpolated)\n\n    if result == 1:\n        # Save results with unique filenames\n        matcher.save_pointmatch(f\"results/point_match_{i}.csv\")\n        matcher.save_routematch(f\"results/route_match_{i}.csv\")\n</code></pre>"},{"location":"user-guide/#adjusting-parameters-for-better-results","title":"Adjusting Parameters for Better Results","text":"<pre><code># For high GPS accuracy (good devices)\nmatcher = MapMatcher(\n    mynet,\n    MAX_GPS_ERROR=30,      # Smaller error radius\n    MAX_MAP_ERROR=20,\n    DIFF_GPS_ERROR=5\n)\n\n# For low GPS accuracy (poor conditions)\nmatcher = MapMatcher(\n    mynet,\n    MAX_GPS_ERROR=100,     # Larger error radius\n    MAX_MAP_ERROR=60,\n    DIFF_GPS_ERROR=20\n)\n\n# For dense urban areas with many one-way streets\nmatcher = MapMatcher(\n    mynet,\n    MAP_ONE_WAY_FIX=True,\n    U_TURN_ON_ONEWAY=False,\n    LOOP=False  # Disallow loops in dense areas\n)\n</code></pre>"},{"location":"user-guide/#converting-coordinates","title":"Converting Coordinates","text":"<pre><code>from geotools import dfPoint2LonLat, dfLonLat2XY\n\n# Convert matched points back to lat/lon\nmatched_lonlat = dfPoint2LonLat(matcher.matchdf, mynet)\n\n# Convert GPS data to x/y\ngps_xy = dfLonLat2XY(gps, mynet)\n</code></pre>"},{"location":"user-guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/#common-issues","title":"Common Issues","text":"<ol> <li>Map matching fails (returns 0)</li> <li>Check GPS data quality (too many outliers?)</li> <li>Increase <code>MAX_GPS_ERROR</code> and <code>MAX_MAP_ERROR</code></li> <li> <p>Verify network covers the GPS trajectory area</p> </li> <li> <p>Poor match quality (high distances)</p> </li> <li>Check GPS accuracy</li> <li>Verify network data is up-to-date</li> <li> <p>Adjust smoothing parameters in <code>richdata()</code></p> </li> <li> <p>Missing required columns</p> </li> <li>Ensure GPS data has: lon, lat, timestamp, speed, bearing</li> <li> <p>Check column names match exactly</p> </li> <li> <p>Network import fails</p> </li> <li>Verify network file format (SUMO .net or OSM)</li> <li>Check file path is correct</li> <li>Ensure network file is valid</li> </ol>"},{"location":"user-guide/#next-steps","title":"Next Steps","text":"<ul> <li>See API Reference for detailed function documentation</li> <li>Check Configuration for all available parameters</li> <li>Review Algorithms to understand how matching works</li> </ul>"}]}